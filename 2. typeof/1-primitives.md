### **4. Exercises**

#### **Exercise 1: Identify Types**
1. Create variables for each primitive and non-primitive type.
2. Use `typeof` to print their types.

---

#### **Exercise 2: `null` vs `undefined`**
1. Declare a variable without assigning it and check its type.
2. Assign `null` to a variable and check its type.
3. Explain the difference between `null` and `undefined`.

---

#### **Exercise 3: Type Coercion**
1. Add a number and a string. Predict the result.
2. Multiply a number and a string. Predict the result.
3. Convert `true` and `false` to numbers using `Number()`.

---

#### **Exercise 4: Object Properties**
1. Create an object with properties like `name`, `age`, and `hobbies`.
2. Add a method that returns a greeting message using the `name` property.

---

#### **Exercise 5: Using `Symbol`**
1. Create a `Symbol` to uniquely identify an object property.
2. Use the `Symbol` as a key in an object and retrieve the value.

---

#### **Exercise 6: Using `bigint`**
1. Declare a very large number using `bigint`.
2. Try adding a `bigint` and a `number`. Explain the error (if any).

---

### **5. Key Takeaways**
1. **Primitive types** are immutable and represent a single value.
2. **Non-primitive types**, like objects and arrays, store collections and can be modified.
3. Type coercion can lead to unexpected results, so use strict equality (`===`) when possible.
4. `bigint` and `symbol` are powerful but often used in specific scenarios like large integers and unique identifiers.

